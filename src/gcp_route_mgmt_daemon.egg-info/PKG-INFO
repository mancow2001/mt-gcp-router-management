Metadata-Version: 2.4
Name: gcp-route-mgmt-daemon
Version: 0.3.0
Summary: Multi-region GCP backend/BGP health daemon with Cloudflare Magic Transit route control
Author: Your Name
License: Apache-2.0
Requires-Python: >=3.10
Description-Content-Type: text/markdown
Requires-Dist: google-api-python-client>=2.140.0
Requires-Dist: google-auth>=2.30.0
Requires-Dist: google-cloud-logging>=3.11.2
Requires-Dist: python-dotenv>=1.0.1
Requires-Dist: requests>=2.32.3

# GCP route magement daemon

A robust, production-ready daemon for automated health monitoring and route management across Google Cloud Platform (GCP) and Cloudflare Magic Transit infrastructure.

## Overview

The GCP route magement daemon automatically monitors the health of GCP backend services and BGP sessions, then dynamically adjusts BGP route advertisements and Cloudflare Magic Transit route priorities based on health status. This enables automated failover scenarios and traffic engineering for high-availability network architectures.

### Key Features

- **ğŸ¥ Health Monitoring**: Continuous monitoring of GCP backend services and BGP session status
- **ğŸ”„ Automated Failover**: Dynamic BGP route advertisement and Cloudflare priority management
- **ğŸ›¡ï¸ Resilience Patterns**: Circuit breakers, exponential backoff, and graceful error handling
- **ğŸ“Š Comprehensive Observability**: Structured logging with correlation IDs and performance metrics
- **âš™ï¸ Production Ready**: Extensive documentation, error handling, and operational tooling

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   GCP Region 1  â”‚    â”‚   GCP Region 2  â”‚    â”‚   Cloudflare    â”‚
â”‚  (Primary)      â”‚    â”‚  (Secondary)    â”‚    â”‚  Magic Transit  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Backend Servicesâ”‚â—„â”€â”€â”€â”¤ Backend Servicesâ”‚    â”‚ Route Prioritiesâ”‚
â”‚ BGP Router      â”‚    â”‚ BGP Router      â”‚    â”‚ Traffic Steeringâ”‚
â”‚ Health Checks   â”‚    â”‚ BGP Monitoring  â”‚    â”‚ Global Anycast  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  Health Check      â”‚
                    â”‚     Daemon         â”‚
                    â”‚                    â”‚
                    â”‚ â€¢ State Machine    â”‚
                    â”‚ â€¢ Route Manager    â”‚
                    â”‚ â€¢ Circuit Breakers â”‚
                    â”‚ â€¢ Structured Logs  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## State-Based Routing Logic

The daemon uses a state machine to determine routing actions based on health combinations:

| State | Local Health | Remote Health | BGP Status | Primary BGP | Secondary BGP | Cloudflare Priority |
|-------|-------------|---------------|------------|-------------|---------------|-------------------|
| 0 | Any | Any | Any | No Change | No Change | No Change |
| 1 | âœ… Healthy | âœ… Healthy | âœ… UP | Advertise | Withdraw | Primary (100) |
| 2 | âŒ Unhealthy | âœ… Healthy | âœ… UP | Withdraw | Withdraw | Secondary (200) |
| 3 | âœ… Healthy | âŒ Unhealthy | âœ… UP | Advertise | Advertise | Primary (100) |
| 4 | âŒ Unhealthy | âŒ Unhealthy | âœ… UP | Advertise* | Withdraw* | Secondary (200)* |
| 5 | âŒ Unhealthy | âœ… Healthy | âŒ DOWN | Advertise | Withdraw | Secondary (200) |
| 6 | âœ… Healthy | âœ… Healthy | âŒ DOWN | Advertise | Advertise | Primary (100) |

**Notes:**
- **State 0**: Failsafe/default state for unexpected health combinations. Maintains current advertisements without changes.
- **State 4 (*)**: Requires verification before action. On first detection, no changes are made. Actions are only applied after 2 consecutive detections to prevent false positives during transient failures.

### State 4 Verification Logic

State 4 represents a critical scenario where both local and remote regions are unhealthy. To prevent premature failover actions due to transient failures or monitoring glitches, the daemon implements a verification mechanism:

**Verification Process:**
1. **First Detection**: When State 4 is first detected, the daemon enters "verification mode"
   - No BGP route changes are applied
   - No Cloudflare priority changes are made
   - Warning logged: `State 4 detected but requires verification`
   - Counter incremented: 1/2

2. **Second Consecutive Detection**: If State 4 persists on the next health check cycle
   - Verification threshold met (2/2)
   - Emergency routing actions are applied
   - Warning logged: `State 4 VERIFIED after 2 consecutive cycles`
   - Normal State 4 actions executed (advertise primary, withdraw secondary)

3. **Recovery**: If any other state is detected before verification completes
   - Verification counter resets to 0
   - Daemon exits verification mode
   - Normal state actions resume

**Configuration:**
- Default verification threshold: **2 consecutive detections**
- Configured in `daemon.py:348` as `state_4_verification_threshold`
- Typical verification time: ~60-120 seconds (depends on `CHECK_INTERVAL_SECONDS`)

**Rationale:**
This skeptical approach prevents the daemon from making aggressive routing changes during brief monitoring outages or transient network issues, improving overall system stability.

## Installation

### Prerequisites

- Python 3.10+
- GCP Service Account with appropriate permissions
- Cloudflare API token with Magic Transit access
- Network access to GCP and Cloudflare APIs

### Required GCP IAM Permissions

Your service account needs these roles or equivalent permissions:

```yaml
# Minimal required permissions
- roles/compute.viewer                    # Read backend services and router status
- roles/compute.networkAdmin              # Modify BGP advertisements

# Specific permissions for custom roles:
- compute.backendServices.get
- compute.backendServices.getHealth
- compute.routers.get
- compute.routers.getRouterStatus
- compute.routers.update
- compute.regions.get
- compute.projects.get
```

### Cloudflare API Permissions

API token requires:
- **Account:Read** - For token verification
- **Zone:Zone Settings:Edit** - For Magic Transit route management

### Installation Steps

1. **Clone the repository:**
   ```bash
   git clone <repository-url>
   cd gcp-route-mgmt
   ```

2. **Install dependencies:**
   ```bash
   pip install -r requirements.txt
   ```

3. **Install the package:**
   ```bash
   pip install -e .
   ```

4. **Run the automated installer (Linux):**
   ```bash
   sudo ./installer.sh
   ```

## Configuration

### Environment Variables

Create a `.env` file with the following configuration:

```bash
# Logging Configuration
LOGGER_NAME=CENTRAL_RAD_HC
LOG_LEVEL=INFO
LOG_FILE=/var/log/radius_healthcheck_daemon.log
LOG_MAX_BYTES=10485760
LOG_BACKUP_COUNT=5
ENABLE_GCP_LOGGING=false

# Structured Logging
ENABLE_STRUCTURED_CONSOLE=false
ENABLE_STRUCTURED_FILE=true
STRUCTURED_LOG_FILE=/var/log/radius_healthcheck_daemon_structured.json

# GCP Configuration
GCP_PROJECT=your-project-id
GOOGLE_APPLICATION_CREDENTIALS=/path/to/service-account.json
LOCAL_GCP_REGION=us-central1
REMOTE_GCP_REGION=us-east4

# BGP Configuration
BGP_PEER_PROJECT=your-bgp-project-id
LOCAL_BGP_REGION=us-central1
LOCAL_BGP_ROUTER=primary-router
REMOTE_BGP_REGION=us-east4
REMOTE_BGP_ROUTER=secondary-router

# Network Prefixes
PRIMARY_PREFIX=10.137.245.0/25
SECONDARY_PREFIX=10.137.19.0/25

# Cloudflare Configuration
CLOUDFLARE_ACCOUNT_ID=your-account-id
CLOUDFLARE_API_TOKEN=your-api-token
DESCRIPTION_SUBSTRING=datacenter-routes
CLOUDFLARE_PRIMARY_PRIORITY=100
CLOUDFLARE_SECONDARY_PRIORITY=200

# Daemon Settings
CHECK_INTERVAL_SECONDS=60
MAX_RETRIES=3
INITIAL_BACKOFF_SECONDS=1
MAX_BACKOFF_SECONDS=60
CIRCUIT_BREAKER_THRESHOLD=5
CIRCUIT_BREAKER_TIMEOUT_SECONDS=300
```

### Configuration Validation

The daemon validates all configuration on startup:

```bash
python -m gcp_route_mgmt_daemon.config
```

## Usage

### Running the Daemon

**Development/Testing:**
```bash
python -m gcp_route_mgmt_daemon
```

**Production (systemd service):**
```bash
sudo systemctl start gcp-route-mgmt
sudo systemctl enable gcp-route-mgmt
```

### Monitoring and Logs

The daemon provides multiple logging outputs:

1. **Console Logs**: Human-readable operational messages
2. **Regular Log File**: Standard application logs
3. **Structured JSON Logs**: Machine-readable events for analysis
4. **GCP Cloud Logging**: Centralized logging (if enabled)

**View structured logs:**
```bash
# Pretty-print JSON logs
tail -f /var/log/radius_healthcheck_daemon_structured.json | jq '.'

# Filter specific event types
jq '.[] | select(.event_type == "health_check_cycle")' /var/log/radius_healthcheck_daemon_structured.json

# Find state transitions
jq '.[] | select(.event_type == "state_transition")' /var/log/radius_healthcheck_daemon_structured.json
```

## Observability

### Structured Logging

All operational events are logged with structured data:

- **Correlation IDs**: Track related events across health check cycles
- **Performance Metrics**: Duration tracking for all operations
- **Error Context**: Detailed error information for debugging
- **State Transitions**: Complete audit trail of routing decisions

### Key Event Types

- `health_check_cycle`: Complete health check results
- `state_transition`: Routing state changes
- `bgp_advertisement_change`: BGP route modifications
- `cloudflare_route_update`: Cloudflare priority changes
- `circuit_breaker_event`: Resilience pattern activations
- `connectivity_test`: Startup validation results

### GCP Cloud Logging Queries

```bash
# All BGP advertisement changes
jsonPayload.event_type="bgp_advertisement_change"

# Failed operations
jsonPayload.result="failure"

# Events for specific health check cycle
jsonPayload.correlation_id="hc-1692622462-abc12345"

# Circuit breaker opens
jsonPayload.event_type="circuit_breaker_event" AND jsonPayload.operation="opened"
```

## Monitoring and Alerting

### Recommended Alerts

1. **Circuit Breaker Opens**
   ```bash
   jsonPayload.event_type="circuit_breaker_event" AND jsonPayload.operation="opened"
   ```

2. **Repeated BGP Failures**
   ```bash
   jsonPayload.event_type="bgp_advertisement_change" AND jsonPayload.result="failure"
   ```

3. **Frequent State Transitions**
   ```bash
   jsonPayload.event_type="state_transition"
   # Rate: > 5 transitions in 10 minutes
   ```

4. **Health Check Failures**
   ```bash
   jsonPayload.event_type="health_check_result" AND jsonPayload.result="failure"
   ```

### Performance Monitoring

Monitor these metrics from structured logs:

- **Cycle Duration**: `health_check_cycle.duration_ms`
- **API Response Times**: Individual operation `duration_ms`
- **Error Rates**: `result="failure"` events
- **State Stability**: Frequency of `state_transition` events

## Troubleshooting

### Common Issues

**1. Configuration Validation Failures**
```bash
# Check configuration
python -c "
from src.gcp_route_mgmt_daemon.config import Config, validate_configuration
cfg = Config()
errors = validate_configuration(cfg)
if errors:
    print('Errors:', errors)
else:
    print('Configuration valid')
"
```

**2. GCP Connectivity Issues**
```bash
# Test GCP connectivity
gcloud auth application-default print-access-token
gcloud compute backend-services list --project=your-project --filter="region:us-central1"
```

**3. Cloudflare API Issues**
```bash
# Test Cloudflare connectivity
curl -X GET "https://api.cloudflare.com/client/v4/accounts/YOUR_ACCOUNT_ID/tokens/verify" \
  -H "Authorization: Bearer YOUR_API_TOKEN"
```

**4. Permission Issues**
```bash
# Check log file permissions
ls -la /var/log/radius_healthcheck_daemon*
sudo chmod 755 /var/log
```

### Debug Mode

Run with debug logging:
```bash
LOG_LEVEL=DEBUG python -m gcp_route_mgmt_daemon
```

### Correlation ID Tracing

Use correlation IDs to trace issues across health check cycles:
```bash
# Find all events for a specific cycle
grep "hc-1692622462-abc12345" /var/log/radius_healthcheck_daemon.log

# Or in structured logs
jq '.[] | select(.correlation_id == "hc-1692622462-abc12345")' /var/log/radius_healthcheck_daemon_structured.json
```

## Development

### Project Structure

```
gcp-route-mgmt/
â”œâ”€â”€ src/gcp_route_mgmt_daemon/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ __main__.py              # Entry point
â”‚   â”œâ”€â”€ config.py                # Configuration management
â”‚   â”œâ”€â”€ daemon.py                # Main daemon logic
â”‚   â”œâ”€â”€ state.py                 # State machine logic
â”‚   â”œâ”€â”€ structured_events.py     # Structured logging
â”‚   â”œâ”€â”€ logging_setup.py         # Log configuration
â”‚   â”œâ”€â”€ circuit.py               # Circuit breaker patterns
â”‚   â”œâ”€â”€ gcp.py                   # GCP API integration
â”‚   â”œâ”€â”€ cloudflare.py            # Cloudflare API integration
â”‚   â”œâ”€â”€ test_states.py           # Unit tests for state logic
â”‚   â”œâ”€â”€ test_circuit.py          # Unit tests for circuit breaker
â”‚   â”œâ”€â”€ test_gcp.py              # Unit tests for GCP integration
â”‚   â””â”€â”€ test_cloudflare.py       # Unit tests for Cloudflare integration
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ installer.sh
â”œâ”€â”€ pyproject.toml
â””â”€â”€ README.md
```

### Testing

The project includes comprehensive unit tests covering all critical components:

**Test Files:**
- `test_states.py` - State machine and State 4 verification logic (30+ tests)
- `test_circuit.py` - Circuit breaker pattern and exponential backoff (41 tests)
- `test_gcp.py` - GCP API integration and health checks (45 tests)
- `test_cloudflare.py` - Cloudflare API route management (40 tests)

**Running Tests:**
```bash
# Run all tests
python -m unittest discover -s src/gcp_route_mgmt_daemon -p "test_*.py"

# Run specific test file
python -m unittest src/gcp_route_mgmt_daemon/test_states.py
python -m unittest src/gcp_route_mgmt_daemon/test_circuit.py
python -m unittest src/gcp_route_mgmt_daemon/test_gcp.py
python -m unittest src/gcp_route_mgmt_daemon/test_cloudflare.py

# Run with verbose output
python -m unittest discover -v -s src/gcp_route_mgmt_daemon -p "test_*.py"

# Run specific test class
python -m unittest src.gcp_route_mgmt_daemon.test_states.TestStateDetermination
python -m unittest src.gcp_route_mgmt_daemon.test_circuit.TestCircuitBreakerClosedState
```

**Test Coverage:**

**State Machine Tests (test_states.py):**
- All 7 state codes (0-6) with health condition combinations
- State 4 verification logic (2 consecutive detection threshold)
- State transitions and verification reset behavior
- Edge cases and boundary conditions

**Circuit Breaker Tests (test_circuit.py):**
- Circuit breaker initialization and parameter validation
- State transitions (CLOSED â†’ OPEN â†’ HALF_OPEN â†’ CLOSED)
- Failure counting and threshold detection
- Timeout-based recovery testing
- Exponential backoff retry logic with delay calculations
- Thread safety validation
- Edge cases (threshold=1, timeout=1, etc.)

**GCP API Tests (test_gcp.py):**
- Client initialization and credential validation
- Connectivity validation with permission checking
- Backend service health checks (all states: HEALTHY, UNHEALTHY, DRAINING, TIMEOUT, UNKNOWN)
- BGP session monitoring (UP, DOWN, and various states)
- Incomplete API response handling
- HTTP error handling (403, 404, 429, 5xx)
- Structured logging integration

**Cloudflare API Tests (test_cloudflare.py):**
- API connectivity and token validation
- Route filtering by description substring
- Bulk priority updates with optimization (no-op when already at priority)
- Empty routes and no-match scenarios
- HTTP error handling (401, 403, 404, 422, 429, 5xx)
- Timeout and connection error handling
- Case-sensitive matching validation

**Overall Coverage:** ~156 test cases covering ~90% of critical business logic

### Code Quality

The codebase follows Python best practices:

- **Type hints** throughout for better IDE support
- **Comprehensive documentation** for all modules and functions
- **Error handling** with specific exception types
- **Logging standards** with structured events
- **Configuration validation** with helpful error messages
- **Unit tests** for critical state machine logic

## Production Deployment

### Systemd Service

The installer script automatically creates a systemd service at `/etc/systemd/system/gcp-route-mgmt.service`:

```ini
[Unit]
Description=MT GCP Healthcheck & Cloudflare Failover Daemon
After=network.target

[Service]
Type=simple
WorkingDirectory=/opt/gcp-route-mgmt
Environment=PYTHONPATH=/opt/gcp-route-mgmt/src:$PYTHONPATH
EnvironmentFile=/opt/gcp-route-mgmt/.env
ExecStart=/opt/gcp-route-mgmt/venv/bin/python -u -m gcp_route_mgmt_daemon
Restart=on-failure
RestartSec=5
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
```

### Log Rotation

Configure log rotation in `/etc/logrotate.d/gcp-route-mgmt`:

```
/var/log/radius_healthcheck_daemon*.log /var/log/radius_healthcheck_daemon*.json {
    daily
    rotate 30
    compress
    delaycompress
    missingok
    notifempty
    copytruncate
}
```

### Uninstalling

To uninstall the daemon:

```bash
sudo ./installer.sh --uninstall
```

## Security Considerations

- **Credentials**: Store service account keys securely, never in version control
- **Permissions**: Use least-privilege IAM roles
- **Network**: Ensure firewall rules allow API access
- **Monitoring**: Watch for unauthorized API usage
- **Rotation**: Regularly rotate service account keys

## Version Information

- **Version**: 0.3.0
- **Python**: 3.10+ required
- **Last Updated**: November 2025
- **Author**: Caffeineoverflow (Nathan Bray)

## Support

For issues and questions:
- Check the troubleshooting section above
- Review structured logs for error details
- Use correlation IDs to trace specific issues
- Open GitHub issues for bugs and feature requests

---

**Ready to deploy**: Use the `installer.sh` script for automated installation and systemd service configuration.
